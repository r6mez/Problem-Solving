{
    "prefixSum2D": {
        "scope": "cpp",
        "prefix": "prefixSum",
        "body": [
            "vector<vi> prefixSum2D(vector<vi>& a) {",
            "    vector<vi> b(a.size(), vi(a[0].size()));",
            "    for (int i = 0; i < a.size(); i++) {",
            "        partial_sum(all(a[i]), b[i].begin());",
            "    }",
            "    for (int i = 0; i < a[0].size(); i++) {",
            "        for (int j = 1; j < a.size(); j++) {",
            "            b[j][i] += b[j - 1][i];",
            "        }",
            "    }",
            "    return b;",
            "}"
        ],
        "description": "Generate a 2D prefix sum array from a 2D input array"
    },
    "sumOfSquare": {
        "scope": "cpp",
        "prefix": "sumOfSquare",
        "body": [
            "int sumOfSquare(int x1, int y1, int x2, int y2, vector<vi>& a) {",
            "    return (a[x2][y2] - a[x1 - 1][y2] - a[x2][y1 - 1]) + a[x1 - 1][y1 - 1];",
            "}"
        ],
        "description": "Calculate the sum of a sub-square in a 2D prefix sum array."
    },
    "getDivisors": {
        "scope": "cpp",
        "prefix": "getDivisors",
        "body": [
            "vi getDivisors(int n) {",
            "    vi divs;",
            "    for (int i = 1; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            divs.push_back(i);",
            "            if (i * i != n) divs.push_back(n / i);",
            "        }",
            "    }",
            "    return divs;",
            "}"
        ],
        "description": "Get all divisors of a number."
    },
    "isPrime": {
        "scope": "cpp",
        "prefix": "isPrime",
        "body": [
            "bool isPrime(int n) {",
            "    if (n == 2) return true;",
            "    if (n == 1 || n % 2 == 0) return false;",
            "    for (int i = 3; i * i <= n; i += 2) {",
            "        if (n % i == 0) return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "Check if a number is prime."
    },
    "isPrimeOptimized": {
        "scope": "cpp",
        "prefix": "isPrimeOptimized",
        "body": [
            "bool isPrime(int n, vi& primes) {",
            "    if (n < 2) return false;",
            "    for (int p : primes) {",
            "        if (p * p > n) break;",
            "        if (n % p == 0) return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "Optimized prime check using a list of primes up to sqrt(n)."
    },
    "getPrimeFactors": {
        "scope": "cpp",
        "prefix": "getPrimeFactors",
        "body": [
            "vector<pll> getPrimeFactors(int n) {",
            "    vector<pll> primeFactors;",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            int count = 0;",
            "            while (n % i == 0) n /= i, count++;",
            "            primeFactors.push_back({i, count});",
            "        }",
            "    }",
            "    if (n > 1) primeFactors.push_back({n, 1});",
            "    return primeFactors;",
            "}"
        ],
        "description": "Get all prime factors of a number along with their counts."
    },
    "modularArithmetic": {
        "scope": "cpp",
        "prefix": "modOps",
        "body": [
            "int add(int a, int b) { return ((a % MOD) + (b % MOD)) % MOD; }",
            "int mul(int a, int b) { return ((a % MOD) * (b % MOD)) % MOD; }",
            "int sub(int a, int b) { return ((((a % MOD) - (b % MOD)) % MOD) + MOD) % MOD; }",
            "int divide(int a, int b) { return mul(a, pwmod(b, MOD - 2)); }"
        ],
        "description": "Provides functions for modular addition, multiplication, subtraction, and division."
    },
    "pwmod": {
        "scope": "cpp",
        "prefix": "pwmod",
        "body": [
            "int pwmod(int b, int p) {",
            "    if (!p) return 1LL;",
            "    int ret = pwmod(b, p >> 1LL);",
            "    ret = mul(ret, ret);",
            "    if (p & 1LL)",
            "        ret = mul(ret, b);",
            "    return ret;",
            "}"
        ],
        "description": "Calculate b^p % MOD using modular exponentiation."
    },
    "linearSieve": {
        "scope": "cpp",
        "prefix": "linearSieve",
        "body": [
            "vi linearSieve(int n) {",
            "    vector<bool> isPr(n + 1, 1);",
            "    vi primes;",
            "    isPr[0] = isPr[1] = 0;",
            "    for (int i = 2; i <= n; i++) {",
            "        if (isPr[i]) primes.push_back(i);",
            "        for (int p : primes) {",
            "            if (i * p >= n + 1) break;",
            "            isPr[i * p] = 0;",
            "            if (i % p == 0) break;",
            "        }",
            "    }",
            "    return primes;",
            "}"
        ],
        "description": "Generate primes up to n using a linear sieve algorithm."
    },
    "nPr": {
        "scope": "cpp",
        "prefix": "nPr",
        "body": [
            "int nPr(int n, int r) {",
            "    int ans = 1;",
            "    for (int i = (n - r) + 1; i <= n; i++) {",
            "        ans *= i;",
            "        ans %= MOD;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Returns the number of permutations nPr"
    },
    "nCr": {
        "scope": "cpp",
        "prefix": "nCr",
        "body": [
            "int nCr(int n, int r) {",
            "    int ans = 1;",
            "    int div = 1; // r!",
            "    for (int i = r + 1; i <= n; i++) {",
            "        ans = ans * i;",
            "        ans /= div;",
            "        div++;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Returns the number of combinations nCr"
    },
    "nCr2": {
        "scope": "cpp",
        "prefix": "nCr2",
        "body": [
            "const int SizeMax = 1e6 + 2;",
            "",
            "vi fac(0), inv(0);",
            "",
            "void buildFacAndInvFac() {",
            "    fac.resize(SizeMax);",
            "    inv.resize(SizeMax);",
            "    fac[0] = 1;",
            "    for (int i = 1; i < SizeMax; ++i) {",
            "        fac[i] = mul(fac[i - 1], i);",
            "    }",
            "    inv[0] = 1;",
            "    for (int i = 1; i < SizeMax; ++i) {",
            "        inv[i] = pwmod(fac[i], MOD - 2);",
            "    }",
            "}",
            "",
            "int nCr2(int n, int r) {",
            "    if (r > n) return 0;",
            "    return mul(mul(fac[n], inv[n - r]), inv[r]);",
            "}"
        ],
        "description": "Builds factorials and modular inverses, and computes nCr using precomputed values."
    },
    "Segment Tree": {
        "scope": "cpp",
        "prefix": "SegmentTree",
        "body": [
            "struct SegTree {",
            "    typedef int T;",
            "    static constexpr T unit = 0;",
            "    T f(T a, T b) { return a + b; } // (any associative fn)",
            "    vector<T> s; int n;",
            "    SegTree(int n = 0, T def = unit) : s(2 * n, def), n(n) {}",
            "    void update(int pos, T val) {",
            "        for (s[pos += n] = val; pos /= 2;)",
            "            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
            "    }",
            "    T query(int b, int e) { // query [b, e)",
            "        T ra = unit, rb = unit;",
            "        for (b += n, e += n; b < e; b /= 2, e /= 2) {",
            "            if (b % 2) ra = f(ra, s[b++]);",
            "            if (e % 2) rb = f(s[--e], rb);",
            "        }",
            "        return f(ra, rb);",
            "    }",
            "};",
        ],
        "description": "Segment tree for point update range quary"
    },
    "Graph Directions": {
        "scope": "cpp",
        "prefix": "graphDirections",
        "body": [
            "int  dx[] = {-1,   1,   0,   0,  1,  -1,  1, -1};",
            "int  dy[] = { 0,   0,  -1,   1,  1,  -1, -1,  1};",
            "char dr[] = {'U', 'D', 'L', 'R'};",
        ],
        "description": "Three arrays that simplifiy the process of directing a graph"
    },
    "digitDP": {
        "scope": "cpp",
        "prefix": "digitDP",
        "body": [
            "// Digit Dp",
            "int dp[/*max Index*/][/*state */][2]; // dp[pos][state][tight]",
            "string num;",
            "",
            "int solveDP(int pos, int state, bool tight) {",
            "    if (pos == num.size()) {",
            "        return /* what we're calculating */;",
            "    }",
            "",
            "    if (dp[pos][state][tight] != -1) return dp[pos][state][tight];",
            "    ",
            "    int res = 0;",
            "    int limit = tight ?  (num[pos] - '0') : 9;",
            "    ",
            "    for (int digit = 0; digit <= limit; digit++) {",
            "        bool newTight = tight && (digit == limit);",
            "        res += solveDP(pos + 1, /*state modification*/, newTight) ;",
            "    }",
            "    dp[pos][state][tight] = res;",
            "    return res;",
            "}",
        ],
        "description": "Template for digit DP"
    },
    "Topological Sort": {
        "scope": "cpp",
        "prefix": "topologicalSort",
        "body": [
            "//A topological sort takes a directed acyclic graph (DAG) and produces ",
            "//a linear ordering of its vertices such that for every directed edge",
            "// u â†’ v, u comes before v in that order.",
            "// Returns a vector of nodes in a valid order; if a cycle exists, the size will be < n. ",
            "// useful for: Scheduling with Dependencies, Course Prerequisites, ",
            "vi topologicalSort(int n, vector<vi>& adj, vi& inDeg) {",
            "    queue<int> q;",
            "    for (int i = 1; i <= n; i++) {",
            "        if (inDeg[i] == 0)",
            "            q.push(i);",
            "    }",
            "",
            "    vi order;",
            "",
            "    while (!q.empty()) {",
            "        int parent = q.front(); q.pop();",
            "        order.push_back(parent);",
            "        for (int child : adj[parent]) {",
            "            if (--inDeg[child] == 0)",
            "                q.push(child);",
            "        }",
            "    }",
            "    ",
            "    return order;",
            "}",
        ],
        "description": "Topological Sort for Directed Acyclic Graphs (DAGs)"
    },
    "Graph Read Input": {
        "scope": "cpp",
        "prefix": "graphRead",
        "body": [
            "int n, m; cin >> n >> m;",
            "vector<vi> adj(n + 1);",
            "for (int i = 0; i < m; i++){",
            "    int u, v; cin >> u >> v;",
            "    adj[u].push_back(v);",
            "    // adj[v].push_back(u);",
            "}",
        ],
        "description": "Read graph input"
    },
    "FenwickPURQ": {
        "scope": "cpp",
        "prefix": "FenwickPURQ",
        "body": [
            "struct FenwickPURQ {    ",
            "    int n;",
            "    vi f;",
            "",
            "    void add(int idx, int val) {",
            "        for (; idx <= n; idx += idx & -idx) f[idx] += val;",
            "    }",
            "    ",
            "    int prefix(int idx) {",
            "        int res = 0;",
            "        for (; idx > 0; idx -= idx & -idx) res += f[idx];",
            "        return res;",
            "    }",
            "    ",
            "    FenwickPURQ(int size) : n(size), f(n + 1, 0) {}",
            "",
            "    int rangeQuery(int l, int r) {",
            "        return prefix(r) - prefix(l - 1);",
            "    }",
            "",
            "    int lower_bound(int v){",
            "        int sum = 0, pos = 0;",
            "        for(int i = ceil(log2(n)); i >= 0; i--){",
            "            int nextPos = pos + (1 << i);",
            "            if(pos + (1 << i) < n && sum + f[nextPos] < v){",
            "                sum += f[nextPos];",
            "                pos = nextPos;",
            "            }",
            "        }",
            "        return pos + 1;",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "FenwickRUPQ": {
        "scope": "cpp",
        "prefix": "FenwickRUPQ",
        "body": [
            "struct FenwickRUPQ {",
            "    int n;",
            "    vi f;",
            "    FenwickRUPQ(int _n) : n(_n), f(n + 1, 0) {}",
            "",
            "    void update(int idx, int val) {",
            "        for (; idx <= n; idx += idx & -idx)",
            "            f[idx] += val;",
            "    }",
            "",
            "    void rangeAdd(int l, int r, int val) {",
            "        update(l, val);",
            "        if (r + 1 <= n) update(r + 1, -val);",
            "    }",
            "",
            "    int pointQuery(int idx) {",
            "        int res = 0;",
            "        for (; idx > 0; idx -= idx & -idx) res += f[idx];",
            "        return res;",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "FenwickRURQ": {
        "scope": "cpp",
        "prefix": "FenwickRURQ",
        "body": [
            "struct FenwickRURQ {",
            "    int n;",
            "    vi B1, B2;",
            "    FenwickRURQ(int size) : n(size), B1(n+1, 0), B2(n+1, 0) {}",
            "",
            "    void add(vi& f, int idx, int val) {",
            "        for (; idx <= n; idx += idx & -idx) f[idx] += val;",
            "    }",
            "",
            "    int prefix(vi& f, int idx){",
            "        int res = 0;",
            "        for (; idx > 0; idx -= idx & -idx) res += f[idx];",
            "        return res;",
            "    }",
            "",
            "    void rangeUpdate(int l, int r, int val) {",
            "        add(B1, l, val);",
            "        add(B1, r + 1, -val);",
            "        add(B2, l, val * (l - 1));",
            "        add(B2, r + 1, -val * r);",
            "    }",
            "",
            "    int prefixQuery(int idx){",
            "        int sumB1 = prefix(B1, idx);",
            "        int sumB2 = prefix(B2, idx);",
            "        return sumB1 * idx - sumB2;",
            "    }",
            "",
            "    int rangeQuery(int l, int r){",
            "        return prefixQuery(r) - prefixQuery(l - 1);",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "Fenwick2D": {
        "scope": "cpp",
        "prefix": "Fenwick2D",
        "body": [
            "struct Fenwick2D {",
            "    int n, m;",
            "    vector<vector<int>> bit;",
            "",
            "    Fenwick2D(int _n, int _m)",
            "      : n(_n), m(_m),",
            "        bit(n + 1, vector<int>(m + 1, 0)) {}",
            "",
            "    void update(int x, int y, int val) {",
            "        for (int i = x; i <= n; i += i & -i) {",
            "            for (int j = y; j <= m; j += j & -j) {",
            "                bit[i][j] += val;",
            "            }",
            "        }",
            "    }",
            "",
            "    int prefixSum(int x, int y) const {",
            "        int res = 0;",
            "        for (int i = x; i > 0; i -= i & -i) {",
            "            for (int j = y; j > 0; j -= j & -j) {",
            "                res += bit[i][j];",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    int rangeSum(int x1, int y1, int x2, int y2) const {",
            "        return prefixSum(x2, y2)",
            "             - prefixSum(x1 - 1, y2)",
            "             - prefixSum(x2, y1 - 1)",
            "             + prefixSum(x1 - 1, y1 - 1);",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "ordered_set": {
        "scope": "cpp",
        "prefix": "ordered_set",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "using namespace __gnu_pbds;",
            "template <class T>",
            "using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
        ],
        "description": "Prints out the header lines for the ordered set (indexed set)."
    },
}