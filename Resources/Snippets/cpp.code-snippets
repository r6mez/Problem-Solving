{
    "prefixSum2D": {
        "scope": "cpp",
        "prefix": "prefixSum",
        "body": [
            "vector<vi> prefixSum2D(vector<vi>& a) {",
            "    vector<vi> b(a.size(), vi(a[0].size()));",
            "    for (int i = 0; i < a.size(); i++) {",
            "        partial_sum(all(a[i]), b[i].begin());",
            "    }",
            "    for (int i = 0; i < a[0].size(); i++) {",
            "        for (int j = 1; j < a.size(); j++) {",
            "            b[j][i] += b[j - 1][i];",
            "        }",
            "    }",
            "    return b;",
            "}"
        ],
        "description": "Generate a 2D prefix sum array from a 2D input array"
    },
    "sumOfSquare": {
        "scope": "cpp",
        "prefix": "sumOfSquare",
        "body": [
            "int sumOfSquare(int x1, int y1, int x2, int y2, vector<vi>& a) {",
            "    return (a[x2][y2] - a[x1 - 1][y2] - a[x2][y1 - 1]) + a[x1 - 1][y1 - 1];",
            "}"
        ],
        "description": "Calculate the sum of a sub-square in a 2D prefix sum array."
    },
    "getDivisors": {
        "scope": "cpp",
        "prefix": "getDivisors",
        "body": [
            "vi getDivisors(int n) {",
            "    vi divs;",
            "    for (int i = 1; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            divs.push_back(i);",
            "            if (i * i != n) divs.push_back(n / i);",
            "        }",
            "    }",
            "    return divs;",
            "}"
        ],
        "description": "Get all divisors of a number."
    },
    "isPrime": {
        "scope": "cpp",
        "prefix": "isPrime",
        "body": [
            "bool isPrime(int n) {",
            "    if (n == 2) return true;",
            "    if (n == 1 || n % 2 == 0) return false;",
            "    for (int i = 3; i * i <= n; i += 2) {",
            "        if (n % i == 0) return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "Check if a number is prime."
    },
    "isPrimeOptimized": {
        "scope": "cpp",
        "prefix": "isPrimeOptimized",
        "body": [
            "bool isPrime(int n, vi& primes) {",
            "    if (n < 2) return false;",
            "    for (int p : primes) {",
            "        if (p * p > n) break;",
            "        if (n % p == 0) return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "Optimized prime check using a list of primes up to sqrt(n)."
    },
    "getPrimeFactors": {
        "scope": "cpp",
        "prefix": "getPrimeFactors",
        "body": [
            "vector<pll> getPrimeFactors(int n) {",
            "    vector<pll> primeFactors;",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            int count = 0;",
            "            while (n % i == 0) n /= i, count++;",
            "            primeFactors.push_back({i, count});",
            "        }",
            "    }",
            "    if (n > 1) primeFactors.push_back({n, 1});",
            "    return primeFactors;",
            "}"
        ],
        "description": "Get all prime factors of a number along with their counts."
    },
    "pwmod": {
        "scope": "cpp",
        "prefix": "pwmod",
        "body": [
            "int pwmod(int a, int b, int m) {",
            "    a %= m;",
            "    int result = 1;",
            "    while (b > 0) {",
            "        if (b & 1) result = (result * a) % m;",
            "        a = (a * a) % m;",
            "        b /= 2;",
            "    }",
            "    return result;",
            "}",
        ],
        "description": "Calculate b^p % MOD using modular exponentiation."
    },
    "sieve": {
        "scope": "cpp",
        "prefix": "sieve",
        "body": [
            "vi seive(int n){",
            "    vi primes;",
            "    vector<bool> isPrime(n+1, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for (int i = 2; i <= n; i++) {",
            "        if (!isPrime[i]) continue;",
            "        primes.push_back(i); ",
            "        for (int j = i * i; j <= n; j += i){",
            "            isPrime[j] = false;",
            "        }",
            "    }",
            "    return primes;",
            "}",
        ],
        "description": "Generate primes up to n using a linear sieve algorithm. O(n log log n)"
    },
    "linearSieve": {
        "scope": "cpp",
        "prefix": "linearSieve",
        "body": [
            "vi linearSieve(int n) {",
            "    vector<bool> isPr(n + 1, 1);",
            "    vi primes;",
            "    isPr[0] = isPr[1] = 0;",
            "    for (int i = 2; i <= n; i++) {",
            "        if (isPr[i]) primes.push_back(i);",
            "        for (int p : primes) {",
            "            if (i * p >= n + 1) break;",
            "            isPr[i * p] = 0;",
            "            if (i % p == 0) break;",
            "        }",
            "    }",
            "    return primes;",
            "}"
        ],
        "description": "Generate primes up to n using a linear sieve algorithm. O(n)"
    },
    "Combinatorics": {
        "scope": "cpp",
        "prefix": "Combinatorics",
        "body": [
            "namespace combinatorics {",
            "    vector<int> fact, inv, invFact;",
            "",
            "    int pwmod(int a, int b) {",
            "        a %= MOD;",
            "        int result = 1;",
            "        while (b > 0) {",
            "            if (b & 1) result = (result * a) % MOD;",
            "            a = (a * a) % MOD;",
            "            b /= 2;",
            "        }",
            "        return result;",
            "    }",
            "",
            "    int inverse(int x) { return pwmod(x, MOD - 2); }",
            "    int multiply(int a, int b) { return ((a % MOD) * (b % MOD)) % MOD; }",
            "    int divide(int a, int b) { return multiply(a, inverse(b)); }",
            "",
            "    void init(int n) {",
            "        fact.resize(n + 1); inv.resize(n + 1); invFact.resize(n + 1);",
            "        fact[0] = fact[1] = inv[0] = inv[1] = invFact[0] = invFact[1] = 1; ",
            "        for (int i = 2; i <= n; ++i){",
            "            fact[i] = fact[i - 1] * i % MOD;",
            "            inv[i] = MOD - ((MOD / i) * inv[MOD % i]) % MOD;",
            "            invFact[i] = invFact[i - 1] * inv[i] % MOD;",
            "        } ",
            "    }",
            "",
            "    int nPr(int n, int r) {",
            "        if (n < 0 || r < 0 || r > n) return 0;",
            "        return fact[n] * invFact[n - r] % MOD;",
            "    }",
            "",
            "    int nCr(int n, int r) {",
            "        if (n < 0 || r < 0 || r > n) return 0;",
            "        return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;",
            "    }",
            "",
            "    int nPrLinear(int n, int r){",
            "        int answer = 1;",
            "        for (int i = n - r + 1; i <= n; i++){",
            "            answer = multiply(answer, i);",
            "        }",
            "        return answer;",
            "    }",
            "",
            "    int nCrLinear(int n, int r){",
            "        int answer = 1;",
            "        for (int i = r + 1; i <= n; i++){",
            "            answer = multiply(answer, i);",
            "            answer = divide(answer, i - r);",
            "        }",
            "        return answer;",
            "    }",
            "};",
            "using namespace combinatorics;",
        ],
        "description": "All functions needed in combinatorics."
    },  
    "Segment Tree": {
        "scope": "cpp",
        "prefix": "SegmentTree",
        "body": [
            "struct SegTree {",
            "    typedef int T;",
            "    static constexpr T unit = 0;",
            "    T f(T a, T b) { return a + b; } // (any associative fn)",
            "    vector<T> s; int n;",
            "    SegTree(int n = 0, T def = unit) : s(2 * n, def), n(n) {}",
            "    void update(int pos, T val) {",
            "        for (s[pos += n] = val; pos /= 2;)",
            "            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
            "    }",
            "    T query(int b, int e) { // query [b, e)",
            "        T ra = unit, rb = unit;",
            "        for (b += n, e += n; b < e; b /= 2, e /= 2) {",
            "            if (b % 2) ra = f(ra, s[b++]);",
            "            if (e % 2) rb = f(s[--e], rb);",
            "        }",
            "        return f(ra, rb);",
            "    }",
            "};",
        ],
        "description": "Segment tree for point update range quary"
    },
    "Graph Directions": {
        "scope": "cpp",
        "prefix": "graphDirections",
        "body": [
            "int  dx[] = {-1,   1,   0,   0,  1,  -1,  1, -1};",
            "int  dy[] = { 0,   0,  -1,   1,  1,  -1, -1,  1};",
            "char dr[] = {'U', 'D', 'L', 'R'};",
        ],
        "description": "Three arrays that simplifiy the process of directing a graph"
    },
    "digitDP": {
        "scope": "cpp",
        "prefix": "digitDP",
        "body": [
            "// Digit Dp",
            "int dp[/*max Index*/][/*state */][2]; // dp[pos][state][tight]",
            "string num;",
            "",
            "int solveDP(int pos, int state, bool tight) {",
            "    if (pos == num.size()) {",
            "        return /* what we're calculating */;",
            "    }",
            "",
            "    if (dp[pos][state][tight] != -1) return dp[pos][state][tight];",
            "    ",
            "    int res = 0;",
            "    int limit = tight ?  (num[pos] - '0') : 9;",
            "    ",
            "    for (int digit = 0; digit <= limit; digit++) {",
            "        bool newTight = tight && (digit == limit);",
            "        res += solveDP(pos + 1, /*state modification*/, newTight) ;",
            "    }",
            "    dp[pos][state][tight] = res;",
            "    return res;",
            "}",
        ],
        "description": "Template for digit DP"
    },
    "Topological Sort": {
        "scope": "cpp",
        "prefix": "topologicalSort",
        "body": [
            "//A topological sort takes a directed acyclic graph (DAG) and produces ",
            "//a linear ordering of its vertices such that for every directed edge",
            "// u → v, u comes before v in that order.",
            "// Returns a vector of nodes in a valid order; if a cycle exists, the size will be < n. ",
            "// useful for: Scheduling with Dependencies, Course Prerequisites, ",
            "vi topologicalSort(int n, vector<vi>& adj, vi& inDeg) {",
            "    queue<int> q;",
            "    for (int i = 1; i <= n; i++) {",
            "        if (inDeg[i] == 0)",
            "            q.push(i);",
            "    }",
            "",
            "    vi order;",
            "",
            "    while (!q.empty()) {",
            "        int parent = q.front(); q.pop();",
            "        order.push_back(parent);",
            "        for (int child : adj[parent]) {",
            "            if (--inDeg[child] == 0)",
            "                q.push(child);",
            "        }",
            "    }",
            "    ",
            "    return order;",
            "}",
        ],
        "description": "Topological Sort for Directed Acyclic Graphs (DAGs)"
    },
    "Graph Read Input": {
        "scope": "cpp",
        "prefix": "graphRead",
        "body": [
            "int n, m; cin >> n >> m;",
            "vector<vi> adj(n + 1);",
            "for (int i = 0; i < m; i++){",
            "    int u, v; cin >> u >> v;",
            "    adj[u].push_back(v);",
            "    // adj[v].push_back(u);",
            "}",
        ],
        "description": "Read graph input"
    },
    "FenwickPURQ": {
        "scope": "cpp",
        "prefix": "FenwickPURQ",
        "body": [
            "struct FenwickPURQ {    ",
            "    int n;",
            "    vi f;",
            "",
            "    void add(int idx, int val) {",
            "        for (; idx <= n; idx += idx & -idx) f[idx] += val;",
            "    }",
            "    ",
            "    int prefix(int idx) {",
            "        int res = 0;",
            "        for (; idx > 0; idx -= idx & -idx) res += f[idx];",
            "        return res;",
            "    }",
            "    ",
            "    FenwickPURQ(int size) : n(size), f(n + 1, 0) {}",
            "",
            "    int rangeQuery(int l, int r) {",
            "        return prefix(r) - prefix(l - 1);",
            "    }",
            "",
            "    int lower_bound(int v){",
            "        int sum = 0, pos = 0;",
            "        for(int i = ceil(log2(n)); i >= 0; i--){",
            "            int nextPos = pos + (1 << i);",
            "            if(pos + (1 << i) < n && sum + f[nextPos] < v){",
            "                sum += f[nextPos];",
            "                pos = nextPos;",
            "            }",
            "        }",
            "        return pos + 1;",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "FenwickRUPQ": {
        "scope": "cpp",
        "prefix": "FenwickRUPQ",
        "body": [
            "struct FenwickRUPQ {",
            "    int n;",
            "    vi f;",
            "    FenwickRUPQ(int _n) : n(_n), f(n + 1, 0) {}",
            "",
            "    void update(int idx, int val) {",
            "        for (; idx <= n; idx += idx & -idx)",
            "            f[idx] += val;",
            "    }",
            "",
            "    void rangeAdd(int l, int r, int val) {",
            "        update(l, val);",
            "        if (r + 1 <= n) update(r + 1, -val);",
            "    }",
            "",
            "    int pointQuery(int idx) {",
            "        int res = 0;",
            "        for (; idx > 0; idx -= idx & -idx) res += f[idx];",
            "        return res;",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "FenwickRURQ": {
        "scope": "cpp",
        "prefix": "FenwickRURQ",
        "body": [
            "struct FenwickRURQ {",
            "    int n;",
            "    vi B1, B2;",
            "    FenwickRURQ(int size) : n(size), B1(n+1, 0), B2(n+1, 0) {}",
            "",
            "    void add(vi& f, int idx, int val) {",
            "        for (; idx <= n; idx += idx & -idx) f[idx] += val;",
            "    }",
            "",
            "    int prefix(vi& f, int idx){",
            "        int res = 0;",
            "        for (; idx > 0; idx -= idx & -idx) res += f[idx];",
            "        return res;",
            "    }",
            "",
            "    void rangeUpdate(int l, int r, int val) {",
            "        add(B1, l, val);",
            "        add(B1, r + 1, -val);",
            "        add(B2, l, val * (l - 1));",
            "        add(B2, r + 1, -val * r);",
            "    }",
            "",
            "    int prefixQuery(int idx){",
            "        int sumB1 = prefix(B1, idx);",
            "        int sumB2 = prefix(B2, idx);",
            "        return sumB1 * idx - sumB2;",
            "    }",
            "",
            "    int rangeQuery(int l, int r){",
            "        return prefixQuery(r) - prefixQuery(l - 1);",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "Fenwick2D": {
        "scope": "cpp",
        "prefix": "Fenwick2D",
        "body": [
            "struct Fenwick2D {",
            "    int n, m;",
            "    vector<vector<int>> bit;",
            "",
            "    Fenwick2D(int _n, int _m)",
            "      : n(_n), m(_m),",
            "        bit(n + 1, vector<int>(m + 1, 0)) {}",
            "",
            "    void update(int x, int y, int val) {",
            "        for (int i = x; i <= n; i += i & -i) {",
            "            for (int j = y; j <= m; j += j & -j) {",
            "                bit[i][j] += val;",
            "            }",
            "        }",
            "    }",
            "",
            "    int prefixSum(int x, int y) const {",
            "        int res = 0;",
            "        for (int i = x; i > 0; i -= i & -i) {",
            "            for (int j = y; j > 0; j -= j & -j) {",
            "                res += bit[i][j];",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    int rangeSum(int x1, int y1, int x2, int y2) const {",
            "        return prefixSum(x2, y2)",
            "             - prefixSum(x1 - 1, y2)",
            "             - prefixSum(x2, y1 - 1)",
            "             + prefixSum(x1 - 1, y1 - 1);",
            "    }",
            "};",
        ],
        "description": "Fenwick tree"
    },
    "Fenwick2DAdd": {
        "scope": "cpp",
        "prefix": "Fenwick2DAdd",
        "body": [
            "struct Fenwick2DAdd {",
            "    int n, m;",
            "    vector<vi> T1, T2, T3, T4;",
            "",
            "    Fenwick2DAdd(int _n, int _m)",
            "        : n(_n), m(_m),",
            "        T1(n + 1, vi(m + 1)),",
            "        T2(n + 1, vi(m + 1)),",
            "        T3(n + 1, vi(m + 1)),",
            "        T4(n + 1, vi(m + 1))",
            "    {    ",
            "}",
            "",
            "    void add(vector<vi>& t, int x, int y, int v) {",
            "        for (int i = x; i <= n; i += i & -i)",
            "            for (int j = y; j <= m; j += j & -j)",
            "                t[i][j] += v;",
            "    }",
            "",
            "    void rangeAdd(int x, int y, int v) {",
            "        add(T1, x, y, v);",
            "        add(T2, x, y, v * (y - 1));",
            "        add(T3, x, y, v * (x - 1));",
            "        add(T4, x, y, v * (x - 1) * (y - 1));",
            "    }",
            "",
            "    void rangeUpdate(int x1, int y1, int x2, int y2, int val) {",
            "        rangeAdd(x1, y1, val);",
            "        rangeAdd(x1, y2 + 1, -val);",
            "        rangeAdd(x2 + 1, y1, -val);",
            "        rangeAdd(x2 + 1, y2 + 1, val);",
            "    }",
            "",
            "    int prefixSum(int x, int y) const {",
            "        int s1 = 0, s2 = 0, s3 = 0, s4 = 0;",
            "        for (int i = x; i > 0; i -= i & -i)",
            "            for (int j = y; j > 0; j -= j & -j) {",
            "                s1 += T1[i][j];",
            "                s2 += T2[i][j];",
            "                s3 += T3[i][j];",
            "                s4 += T4[i][j];",
            "            }",
            "        return s1 * x * y - s2 * x - s3 * y + s4;",
            "    }",
            "",
            "    int rangeQuery(int x1, int y1, int x2, int y2) const {",
            "        return prefixSum(x2, y2)",
            "            - prefixSum(x1 - 1, y2)",
            "            - prefixSum(x2, y1 - 1)",
            "            + prefixSum(x1 - 1, y1 - 1);",
            "    }",
            "};",
        ],
        "description": "Fenwick 2D that supports square add and square sum"
    },    
    "Fenwick2DXOR": {
        "scope": "cpp",
        "prefix": "Fenwick2DXOR",
        "body": [
            "struct Fenwick2DXOR {",
            "    int n, m;",
            "    vector<vi> bit[2][2];",
            "",
            "    Fenwick2DXOR(int _n, int _m) : n(_n), m(_m) {",
            "        for (int px = 0; px < 2; ++px)",
            "            for (int py = 0; py < 2; ++py)",
            "                bit[px][py].assign(n+2, vi(m+2, 0));",
            "    }",
            "",
            "    void pointXOR(int x, int y, int v) {",
            "        for (int i = x; i <= n; i += i & -i)",
            "            for (int j = y; j <= m; j += j & -j)",
            "                bit[x&1][y&1][i][j] ^= v;",
            "    }",
            "",
            "    void rangeXOR(int x1, int y1, int x2, int y2, int v) {",
            "        if (x1 > x2 || y1 > y2) return;",
            "        auto upd = [&](int x, int y){ if (x > 0 && y > 0) pointXOR(x, y, v); };",
            "        upd(x1,      y1);",
            "        upd(x2 + 1,  y1);",
            "        upd(x1,      y2 + 1);",
            "        upd(x2 + 1,  y2 + 1);",
            "    }",
            "",
            "    int prefixXOR(int x, int y) {",
            "        if (x <= 0 || y <= 0) return 0;",
            "        int res = 0;",
            "        int px = x & 1, py = y & 1;",
            "        for (int i = x; i > 0; i -= i & -i)",
            "            for (int j = y; j > 0; j -= j & -j)",
            "                res ^= bit[px][py][i][j];",
            "        return res;",
            "    }",
            "",
            "    int rangeQuery(int x1, int y1, int x2, int y2) {",
            "        int res = 0;",
            "        res ^= prefixXOR(x2,   y2);",
            "        res ^= prefixXOR(x1-1, y2);",
            "        res ^= prefixXOR(x2,   y1-1);",
            "        res ^= prefixXOR(x1-1, y1-1);",
            "        return res;",
            "    }",
            "};",
        ],
        "description": "Fenwick 2D that supports square XOR and square sum"
    },
    "ordered_set": {
        "scope": "cpp",
        "prefix": "ordered_set",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "using namespace __gnu_pbds;",
            "template <class T>",
            "using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
        ],
        "description": "Prints out the header lines for the ordered set (indexed set)."
    },
    "randomNumber": {
        "scope": "cpp",
        "prefix": "randomNumber",
        "body": [
            "mt19937_64 randomNumber(chrono::high_resolution_clock::now().time_since_epoch().count());",
        ],
        "description": "a function that generates a random 64 bit number"
    },
    "DSU": {
        "scope": "cpp",
        "prefix": "DSU",
        "body": [
            "struct DSU {",
            "    vector<int> parent, size;",
            "    int count; // of component",
            "",
            "    DSU(int n) : parent(n + 1), size(n + 1, 1), count(n) { iota(all(parent), 0); }",
            "",
            "    int find(int i) { return (parent[i] == i ? i : (parent[i] = find(parent[i]))); }",
            "",
            "    bool same(int i, int j) { return find(i) == find(j); }",
            "",
            "    int getSize(int i) { return size[find(i)]; }",
            "",
            "    int merge(int i, int j) {",
            "        if ((i = find(i)) == (j = find(j))) return -1;",
            "        else --count;",
            "        if (size[i] > size[j]) swap(i, j);",
            "        parent[i] = j;",
            "        size[j] += size[i];        ",
            "        return j;",
            "    }",
            "};",
        ],
        "description": "Disjoint union sit."
    },
}